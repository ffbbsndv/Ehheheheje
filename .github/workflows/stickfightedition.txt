local Guns = {unpack(game.ReplicatedStorage.Weapons:GetChildren())}
local CurrentGuns = {unpack(game.Workspace.Tools:GetChildren())}

for _, v in pairs(game.ReplicatedStorage.Weapons:GetChildren()) do
	table.insert(Guns, v.Name)
end

for _, v in pairs(game.Workspace.Tools:GetChildren()) do
	table.insert(CurrentGuns, v.Name)
end

function GetGun(Gun)
    local args = {
        true,
        game:GetService("ReplicatedStorage").Weapons[Gun].Handle,
        game.Players.LocalPlayer.Character
    }
    game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("EquipWeapon"):FireServer(unpack(args))    
end

function GetGunForOtherType(Gun)
    local args = {
        true,
        game:GetService("Workspace").Tools[Gun].Handle,
        game.Players.LocalPlayer.Character
    }
    game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("EquipWeapon"):FireServer(unpack(args))    
end

function Teleport()
	local Map = game.Workspace.Map:FindFirstChildWhichIsA("Model")
	local Spawn = Map.Spawns:GetChildren()[math.random(1, #Map.Spawns:GetChildren())]

	for _, v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
		if v:isA("BasePart") or v:isA("Part") then
			v.CFrame = Spawn.CFrame
		end
	end
end

function respawn()
	game:GetService("ReplicatedStorage").RemoteEvents.Respawn:FireServer()
	local lplr = game.Players.LocalPlayer

	lplr.CameraMaxZoomDistance = 228
	lplr.CameraMinZoomDistance = 228
end

local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

local Options = Library.Options
local Toggles = Library.Toggles

Library.ForceCheckbox = false -- Forces AddToggle to AddCheckbox
Library.ShowToggleFrameInKeybinds = true -- Make toggle keybinds work inside the keybinds UI (aka adds a toggle to the UI). Good for mobile users (Default value = true)


local Window = Library:CreateWindow({
	-- Set Center to true if you want the menu to appear in the center
	-- Set AutoShow to true if you want the menu to appear when it is created
	-- Set Resizable to true if you want to have in-game resizable Window
	-- Set MobileButtonsSide to "Left" or "Right" if you want the ui toggle & lock buttons to be on the left or right side of the window
	-- Set ShowCustomCursor to false if you don't want to use the Linoria cursor
	-- NotifySide = Changes the side of the notifications (Left, Right) (Default value = Left)
	-- Position and Size are also valid options here
	-- but you do not need to define them unless you are changing them :)

	Title = "Forest Fire",
	Footer = "V1 Please Join The Discord :  https://discord.gg/W724xdWAuq",
	Icon = 135839551848990,
	NotifySide = "Left",
	ShowCustomCursor = false,
})

local Tabs = {
	-- Creates a new tab titled Main
	Main = Window:AddTab("Main", "user"),
	["UI Settings"] = Window:AddTab("UI Settings", "settings"),
}

local Get = Tabs.Main:AddLeftGroupbox("Weapons")
local Aura = Tabs.Main:AddRightGroupbox("OP")



_G.Keybind = Enum.KeyCode.X

Aura:AddLabel("Revive"):AddKeyPicker("KeyPicker", {
	Default = "X", -- String as the name of the keybind (MB1, MB2 for mouse buttons)
	SyncToggleState = false,

	-- You can define custom Modes but I have never had a use for it.
	Mode = "Hold", -- Modes: Always, Toggle, Hold

	Text = "Revive", -- Text to display in the keybind menu
	NoUI = false, -- Set to true if you want to hide from the Keybind menu,

	-- Occurs when the keybind is clicked, Value is `true`/`false`
	Callback = function(Value)
		print("[cb] Keybind clicked!", Value)
	end,

	-- Occurs when the keybind itself is changed, `New` is a KeyCode Enum OR a UserInputType Enum
	ChangedCallback = function(New)
		_G.Keybind = New
	end,
})

local ED = game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessedEvent)
    local success, got = pcall(function()
        if input.KeyCode == _G.Keybind and not gameProcessedEvent then
			respawn()
			task.wait(1)
			Teleport()  
        end
    end)
end)

Aura:AddLabel("Forcefeild Attack"):AddKeyPicker("Toggle", {
    Default = "H",         -- default mouse button 2
    Mode = "Toggle",         -- press to toggle on/off
    SyncToggleState = false,  -- sync with the “AutoLockToggle” above
    Text = "Forcefeild Attack",
    Callback = function(Value)
		_G.AutoAttack = Value

        -- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

        while _G.AutoAttack do
            task.wait()
            local args = {
				false,
				false,
				vector.create(0.971312403678894, 0.23600022494792938, 0.029259664937853813),
				game:GetService("Players").LocalPlayer.Character:WaitForChild("RightArm")
			}
			game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("Attack"):FireServer(unpack(args))
			local args = {
				false,
				false,
				vector.create(-0.16714727878570557, 0.9854938983917236, -0.029384393244981766),
				game:GetService("Players").LocalPlayer.Character:WaitForChild("LeftArm")
			}
			game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("Attack"):FireServer(unpack(args))
			local args = {
				false,
				false,
				vector.create(-0.8840696811676025, 0.46696561574935913, 0.019077904522418976),
				game:GetService("Players").LocalPlayer.Character:WaitForChild("RightArm")
			}
			game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("Attack"):FireServer(unpack(args))
			
			local args = {
				false,
				false,
				vector.create(-0.9978721737861633, 0.06317546218633652, -0.016122739762067795),
				game:GetService("Players").LocalPlayer.Character:WaitForChild("RightArm")
			}
			game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("Attack"):FireServer(unpack(args))
			
			local args = {
				false,
				false,
				vector.create(-0.8325977325439453, 0.5532859563827515, 0.025605006143450737),
				game:GetService("Players").LocalPlayer.Character:WaitForChild("LeftArm")
			}
			game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("Attack"):FireServer(unpack(args))
			
			local args = {
				false,
				false,
				vector.create(0.6714725494384766, 0.7396631836891174, -0.04497804492712021),
				game:GetService("Players").LocalPlayer.Character:WaitForChild("RightArm")
			}
			game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("Attack"):FireServer(unpack(args))
			
			local args = {
				false,
				false,
				vector.create(0.8705403208732605, -0.4891076982021332, 0.05415833741426468),
				game:GetService("Players").LocalPlayer.Character:WaitForChild("LeftArm")
			}
			game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("Attack"):FireServer(unpack(args))
			
			local args = {
				false,
				false,
				vector.create(-0.9260911345481873, -0.373136430978775, -0.055896200239658356),
				game:GetService("Players").LocalPlayer.Character:WaitForChild("RightArm")
			}
			game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("Attack"):FireServer(unpack(args))
			
			local args = {
				false,
				false,
				vector.create(-0.18719284236431122, -0.9745944142341614, 0.12298144400119781),
				game:GetService("Players").LocalPlayer.Character:WaitForChild("LeftArm")
			}
			game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("Attack"):FireServer(unpack(args))
			
        end
    end,
})

Get:AddDropdown("Dropdown", {
	Values = Guns,
	Default = 0, -- number index of the value / string
	Multi = false, -- true / false, allows multiple choices to be selected

	Text = "One Time Guns!",
	Tooltip = "Select A Gun To Do The Action Below", -- Information shown when you hover over the dropdown
	DisabledTooltip = "I am disabled!", -- Information shown when you hover over the dropdown while it's disabled

	Searchable = true, -- true / false, makes the dropdown searchable (great for a long list of values)

	Callback = function(Value)
		_G.Gun = Value
	end,

	Disabled = false, -- Will disable the dropdown (true / false)
	Visible = true, -- Will make the dropdown invisible (true / false)
})

Get:AddDropdown("GunsCurrentlyInGame", {
	Values = {"No Guns Found!"},
	Default = 0, -- number index of the value / string
	Multi = false, -- true / false, allows multiple choices to be selected

	Text = "Current Guns!",
	Tooltip = "Select A Gun To Do The Action Below", -- Information shown when you hover over the dropdown
	DisabledTooltip = "I am disabled!", -- Information shown when you hover over the dropdown while it's disabled

	Searchable = true, -- true / false, makes the dropdown searchable (great for a long list of values)

	Callback = function(Value)
		_G.GunByte = Value
	end,

	Disabled = false, -- Will disable the dropdown (true / false)
	Visible = true, -- Will make the dropdown invisible (true / false)
})

Get:AddDropdown("Dropdown", {
	Values = {"Current", "One Time Uses (Risky Can Break Game)"},
	Default = 0, -- number index of the value / string
	Multi = false, -- true / false, allows multiple choices to be selected

	Text = "Guns Options!",
	Tooltip = "Select A Gun Option", -- Information shown when you hover over the dropdown
	DisabledTooltip = "I am disabled!", -- Information shown when you hover over the dropdown while it's disabled

	Searchable = true, -- true / false, makes the dropdown searchable (great for a long list of values)

	Callback = function(Value)
		_G.GunMode = Value
	end,

	Disabled = false, -- Will disable the dropdown (true / false)
	Visible = true, -- Will make the dropdown invisible (true / false)
})

_G.SkibidiToila = Enum.KeyCode.N

Get:AddLabel("Get Gun"):AddKeyPicker("KeyPicker", {
	Default = "N", -- String as the name of the keybind (MB1, MB2 for mouse buttons)
	SyncToggleState = false,

	-- You can define custom Modes but I have never had a use for it.
	Mode = "Hold", -- Modes: Always, Toggle, Hold

	Text = "Get Gun", -- Text to display in the keybind menu
	NoUI = false, -- Set to true if you want to hide from the Keybind menu,

	-- Occurs when the keybind is clicked, Value is `true`/`false`
	Callback = function(Value)
		print("[cb] Keybind clicked!", Value)
	end,

	-- Occurs when the keybind itself is changed, `New` is a KeyCode Enum OR a UserInputType Enum
	ChangedCallback = function(New)
		_G.SkibidiToila = New
	end,
})

local E = game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessedEvent)
    local success, got = pcall(function()
        if input.KeyCode == _G.SkibidiToila and not gameProcessedEvent then
			if _G.GunMode == "Current" then
				GetGunForOtherType(tostring(_G.GunByte))
			else
				GetGun(tostring(_G.Gun))
			end
        end
    end)
end)

local MenuGroup = Tabs["UI Settings"]:AddLeftGroupbox("Menu")

Library.KeybindFrame.Visible = true

MenuGroup:AddToggle("KeybindMenuOpen", {
	Default = Library.KeybindFrame.Visible,
	Text = "Open Keybind Menu",
	Callback = function(value)
		Library.KeybindFrame.Visible = value
	end,
})
MenuGroup:AddToggle("ShowCustomCursor", {
	Text = "Custom Cursor",
	Default = true,
	Callback = function(Value)
		Library.ShowCustomCursor = Value
	end,
})
MenuGroup:AddDropdown("NotificationSide", {
	Values = { "Left", "Right" },
	Default = "Right",

	Text = "Notification Side",

	Callback = function(Value)
		Library:SetNotifySide(Value)
	end,
})
MenuGroup:AddDropdown("DPIDropdown", {
	Values = { "50%", "75%", "100%", "125%", "150%", "175%", "200%" },
	Default = "100%",

	Text = "DPI Scale",

	Callback = function(Value)
		Value = Value:gsub("%%", "")
		local DPI = tonumber(Value)

		Library:SetDPIScale(DPI)
	end,
})
MenuGroup:AddDivider()

function RecheckTable()
    CurrentGuns = {}
    for _, v in pairs(game.Workspace.Tools:GetChildren()) do
        table.insert(CurrentGuns, v.Name)
    end
    if CurrentGuns == {} then
        CurrentGuns = {"No Guns Found!"}
    end

    Options.GunsCurrentlyInGame:SetValues(CurrentGuns)
end

RecheckTable()

local UpdaterAdded = game.Workspace.Tools.ChildAdded:Connect(function()
    RecheckTable()
end)

local UpdaterRemoved = game.Workspace.Tools.ChildAdded:Connect(function()
    RecheckTable()
end)

MenuGroup:AddLabel("Menu bind"):AddKeyPicker("MenuKeybind", { Default = "RightShift", NoUI = true, Text = "Menu keybind" })

MenuGroup:AddButton("Unload", function()
    UpdaterAdded:Disconnect()
    UpdaterRemoved:Disconnect()
	E:Disconnect()
	ED:Disconnect()
	Library:Unload()
end)

Library.ToggleKeybind = Options.MenuKeybind -- Allows you to have a custom keybind for the menu

-- Addons:
-- SaveManager (Allows you to have a configuration system)
-- ThemeManager (Allows you to have a menu theme system)

-- Hand the library over to our managers
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- Adds our MenuKeybind to the ignore list
-- (do you want each config to have a different menu key? probably not.)
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
ThemeManager:SetFolder("ForestFire")
SaveManager:SetFolder("ForestFire/StickFightRobloxEdition")
SaveManager:SetSubFolder("StickFightRobloxEdition") -- if the game has multiple places inside of it (for example: DOORS)
-- you can use this to save configs for those places separately
-- The path in this script would be: MyScriptHub/specific-game/settings/specific-place
-- [ This is optional ]

-- Builds our config menu on the right side of our tab
SaveManager:BuildConfigSection(Tabs["UI Settings"])

-- Builds our theme menu (with plenty of built in themes) on the left side
-- NOTE: you can also call ThemeManager:ApplyToGroupbox to add it to a specific groupbox
ThemeManager:ApplyToTab(Tabs["UI Settings"])

-- You can use the SaveManager:LoadAutoloadConfig() to load a config
-- which has been marked to be one that auto loads!
SaveManager:LoadAutoloadConfig()
